// Copyright 2025 SolarWinds Worldwide, LLC. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package k8seventgenerationprocessor

import (
	"fmt"
	"strings"

	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/plog"
	conventions "go.opentelemetry.io/otel/semconv/v1.21.0"

	"github.com/solarwinds/solarwinds-otel-collector-contrib/processor/k8seventgenerationprocessor/internal/constants"
	"github.com/solarwinds/solarwinds-otel-collector-contrib/processor/k8seventgenerationprocessor/internal/manifests"
)

func canonicalizeVulnerabilityID(v *manifests.Vulnerability) string {
	// Currently we only have VulnerabilityID from the manifest.
	// If future requirements allow choosing from multiple IDs (CVE, OSV, GHSA),
	// the precedence logic should be implemented here.
	return v.VulnerabilityID
}

func mapWorkloadKindToEntityType(kind string) string {
	switch kind {
	case "Deployment":
		return constants.EntityTypeKubernetesDeployment
	case "DaemonSet":
		return constants.EntityTypeKubernetesDaemonSet
	case "StatefulSet":
		return constants.EntityTypeKubernetesStatefulSet
	default:
		return ""
	}
}

func transformVulnerabilitiesToEntityLogs(manifest *manifests.VulnerabilityReportManifest, timestamp pcommon.Timestamp, clusterUID string) plog.LogRecordSlice {
	logs := plog.NewLogRecordSlice()

	for _, v := range manifest.Report.Vulnerabilities {
		lr := logs.AppendEmpty()
		lr.SetTimestamp(timestamp)
		lr.SetObservedTimestamp(timestamp)

		attrs := lr.Attributes()
		attrs.PutStr(constants.AttributeOtelEntityEventType, constants.EventTypeEntityState)
		attrs.PutStr(constants.AttributeOtelEntityType, constants.EntityTypeVulnerability)

		// Entity ID
		canonicalID := canonicalizeVulnerabilityID(&v)
		entityIDMap := attrs.PutEmptyMap(constants.AttributeOtelEntityID)
		entityIDMap.PutStr(constants.AttributeVulnerabilityID, canonicalID)

		// Entity Attributes
		entityAttrs := attrs.PutEmptyMap(constants.AttributeOtelEntityAttributes)
		entityAttrs.PutStr(constants.AttributeVulnerabilityID, canonicalID)
		entityAttrs.PutStr(constants.AttributeVulnerabilityDescription, v.Title)
		entityAttrs.PutStr(constants.AttributeVulnerabilitySeverity, v.Severity)

		if v.Score > 0 {
			entityAttrs.PutDouble(constants.AttributeVulnerabilityScoreBase, v.Score)
		}

		// Enumeration
		if strings.HasPrefix(canonicalID, "CVE") {
			entityAttrs.PutStr(constants.AttributeVulnerabilityEnumeration, "CVE")
		} else if strings.HasPrefix(canonicalID, "GHSA") {
			entityAttrs.PutStr(constants.AttributeVulnerabilityEnumeration, "GHSA")
		} else if strings.HasPrefix(canonicalID, "OSV") {
			entityAttrs.PutStr(constants.AttributeVulnerabilityEnumeration, "OSV")
		}

		entityAttrs.PutStr(constants.AttributeCweID, canonicalID)

		// Build vulnerability.reference array
		references := entityAttrs.PutEmptySlice(constants.AttributeVulnerabilityReference)
		if v.PrimaryLink != "" {
			references.AppendEmpty().SetStr(v.PrimaryLink)
		}
		for _, link := range v.Links {
			if link != "" && link != v.PrimaryLink {
				references.AppendEmpty().SetStr(link)
			}
		}
		// Map other fields if available in struct
	}

	return logs
}

func transformVulnerabilitiesToFindingLogs(manifest *manifests.VulnerabilityReportManifest, timestamp pcommon.Timestamp, clusterUID string) plog.LogRecordSlice {
	logs := plog.NewLogRecordSlice()

	for _, v := range manifest.Report.Vulnerabilities {
		canonicalID := canonicalizeVulnerabilityID(&v)

		// 1. Relationship to Workload
		if kind, ok := manifest.Metadata.Labels["trivy-operator.resource.kind"]; ok {
			if name, ok := manifest.Metadata.Labels["trivy-operator.resource.name"]; ok {
				if namespace, ok := manifest.Metadata.Labels["trivy-operator.resource.namespace"]; ok {
					entityType := mapWorkloadKindToEntityType(kind)
					if entityType != "" {
						lr := logs.AppendEmpty()
						lr.SetTimestamp(timestamp)
						lr.SetObservedTimestamp(timestamp)

						attrs := lr.Attributes()
						attrs.PutStr(constants.AttributeOtelEntityEventType, constants.EventTypeEntityRelationshipState)
						attrs.PutStr(constants.AttributeOtelEntityRelationshipType, constants.RelationshipTypeVulnerabilityFinding)

						// Source Entity Type and ID (Vulnerability)
						attrs.PutStr(constants.AttributeOtelEntityRelationshipSrcType, constants.EntityTypeVulnerability)
						sourceIDMap := attrs.PutEmptyMap(constants.AttributeOtelEntityRelationshipSourceEntityID)
						sourceIDMap.PutStr(constants.AttributeVulnerabilityID, canonicalID)

						// Destination Entity Type and ID (Workload)
						attrs.PutStr(constants.AttributeOtelEntityRelationshipDstType, entityType)
						destIDMap := attrs.PutEmptyMap(constants.AttributeOtelEntityRelationshipDestinationEntityID)
						destIDMap.PutStr("sw.k8s.cluster.uid", clusterUID)
						destIDMap.PutStr("k8s.namespace.name", namespace)
						// Use workload-specific name attribute based on entity type
						switch kind {
						case "Deployment":
							destIDMap.PutStr("k8s.deployment.name", name)
						case "DaemonSet":
							destIDMap.PutStr("k8s.daemonset.name", name)
						case "StatefulSet":
							destIDMap.PutStr("k8s.statefulset.name", name)
						}

						// Attributes
						relAttrs := attrs.PutEmptyMap(constants.AttributeOtelEntityRelationshipAttributes)
						relAttrs.PutStr(constants.AttributeSwRelationshipType, constants.RelationshipTypeVulnerabilityFinding)
						relAttrs.PutStr(constants.AttributeSwRelationshipFrom, fmt.Sprintf("vulnerability:%s", canonicalID))
						relAttrs.PutStr(constants.AttributeSwRelationshipTo, fmt.Sprintf("k8s.workload:%s:%s:%s:%s", clusterUID, namespace, kind, name))

						populateCommonRelationshipAttributes(relAttrs, manifest)
					}
				}
			}
		}

		// 2. Relationship to Image
		if digest := manifest.Report.Artifact.Digest; digest != "" {
			lr := logs.AppendEmpty()
			lr.SetTimestamp(timestamp)
			lr.SetObservedTimestamp(timestamp)

			attrs := lr.Attributes()
			attrs.PutStr(constants.AttributeOtelEntityEventType, constants.EventTypeEntityRelationshipState)
			attrs.PutStr(constants.AttributeOtelEntityRelationshipType, constants.RelationshipTypeVulnerabilityFinding)

			// Source Entity ID (Vulnerability)
			sourceIDMap := attrs.PutEmptyMap(constants.AttributeOtelEntityRelationshipSourceEntityID)
			sourceIDMap.PutStr(constants.AttributeVulnerabilityID, canonicalID)

			// Destination Entity ID (Image)
			destIDMap := attrs.PutEmptyMap(constants.AttributeOtelEntityRelationshipDestinationEntityID)
			destIDMap.PutStr(string(conventions.ContainerImageIDKey), digest)
			destIDMap.PutStr(string(conventions.ContainerImageNameKey), manifest.Report.Artifact.Repository)
			destIDMap.PutStr(string(conventions.ContainerImageTagKey), manifest.Report.Artifact.Tag)

			// Attributes
			relAttrs := attrs.PutEmptyMap(constants.AttributeOtelEntityRelationshipAttributes)
			relAttrs.PutStr(constants.AttributeSwRelationshipType, constants.RelationshipTypeVulnerabilityFinding)
			relAttrs.PutStr(constants.AttributeSwRelationshipFrom, fmt.Sprintf("vulnerability:%s", canonicalID))
			relAttrs.PutStr(constants.AttributeSwRelationshipTo, fmt.Sprintf("k8s.container.image:%s:%s", clusterUID, digest))

			populateCommonRelationshipAttributes(relAttrs, manifest)
		}
	}

	return logs
}

func populateCommonRelationshipAttributes(attrs pcommon.Map, manifest *manifests.VulnerabilityReportManifest) {
	attrs.PutStr(constants.AttributeScannerVendor, manifest.Report.Scanner.Vendor)
	attrs.PutStr(constants.AttributeScannerName, manifest.Report.Scanner.Name)
	attrs.PutStr(constants.AttributeScannerVersion, manifest.Report.Scanner.Version)
	// Status, CreatedTime, UpdatedTime - not in the example JSON or struct yet, but if they were:
	// attrs.PutStr(constants.AttributeStatus, ...)
}

func transformVulnerabilityReportToContainerImageLog(manifest *manifests.VulnerabilityReportManifest, t pcommon.Timestamp) plog.LogRecordSlice {
	lrs := plog.NewLogRecordSlice()

	if manifest.Report.Artifact.Digest == "" {
		return lrs
	}

	lr := lrs.AppendEmpty()
	lr.SetObservedTimestamp(t)

	attrs := lr.Attributes()
	attrs.PutStr(otelEntityEventType, entityState)
	attrs.PutStr(swEntityType, k8sContainerImageEntityType)

	tm := attrs.PutEmptyMap(otelEntityId)
	tm.PutStr(string(conventions.ContainerImageIDKey), manifest.Report.Artifact.Digest)
	tm.PutStr(string(conventions.ContainerImageNameKey), manifest.Report.Artifact.Repository)
	tm.PutStr(string(conventions.ContainerImageTagKey), manifest.Report.Artifact.Tag)

	return lrs
}
