// Copyright 2025 SolarWinds Worldwide, LLC. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package k8seventgenerationprocessor

import (
	"strings"

	"github.com/google/go-containerregistry/pkg/name"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/plog"
	conventions "go.opentelemetry.io/otel/semconv/v1.21.0"

	"github.com/solarwinds/solarwinds-otel-collector-contrib/processor/k8seventgenerationprocessor/internal/constants"
	"github.com/solarwinds/solarwinds-otel-collector-contrib/processor/k8seventgenerationprocessor/internal/manifests"
)

func extractSha256Digest(fullDigest string) string {
	if fullDigest == "" {
		return ""
	}

	// Strip container runtime prefixes
	runtimePrefixes := []string{
		"docker://",
		"containerd://",
		"cri-o://",
		"docker-pullable://",
	}

	digest := fullDigest
	for _, prefix := range runtimePrefixes {
		digest = strings.TrimPrefix(digest, prefix)
	}

	// Extract digest after @ symbol (e.g., "nginx@sha256:abc")
	if idx := strings.Index(digest, "@"); idx != -1 {
		digest = digest[idx+1:]
	}

	// Check if digest contains an algorithm prefix (sha256:, sha512:, etc.)
	if idx := strings.Index(digest, ":"); idx != -1 {
		algorithm := digest[:idx]
		hash := digest[idx+1:]
		// Normalize algorithm to lowercase
		return strings.ToLower(algorithm) + ":" + hash
	}

	// No algorithm prefix found, assume sha256
	return "sha256:" + digest
}

func normalizeVulnerabilityReportImage(registry, repository, tag string) string {
	if repository == "" {
		return ""
	}

	// Reconstruct full image reference from Trivy's split format
	imageRef := repository

	// Prepend registry server if present
	if registry != "" {
		imageRef = registry + "/" + repository
	}

	// Append tag if present
	if tag != "" {
		imageRef += ":" + tag
	}

	// Parse using go-containerregistry to normalize and get full registry+repository
	ref, err := name.ParseReference(imageRef)
	if err != nil {
		// Fall back to constructed imageRef (preserves registry)
		return imageRef
	}

	// Use Name() to get full registry+repository path (not RepositoryStr())
	// This matches OTel semantics and ensures proper entity matching
	return ref.Context().Name()
}

func canonicalizeVulnerabilityID(v *manifests.Vulnerability) string {
	// Currently we only have VulnerabilityID from the manifest.
	// If future requirements allow choosing from multiple IDs (CVE, OSV, GHSA),
	// the precedence logic should be implemented here.
	return v.VulnerabilityID
}

func transformVulnerabilitiesToEntityLogs(manifest *manifests.VulnerabilityReportManifest, timestamp pcommon.Timestamp, clusterUID string) plog.LogRecordSlice {
	logs := plog.NewLogRecordSlice()

	for _, v := range manifest.Report.Vulnerabilities {
		lr := logs.AppendEmpty()
		lr.SetTimestamp(timestamp)
		lr.SetObservedTimestamp(timestamp)

		attrs := lr.Attributes()
		attrs.PutStr(constants.AttributeOtelEntityEventType, constants.EventTypeEntityState)
		attrs.PutStr(constants.AttributeOtelEntityType, constants.EntityTypeVulnerability)

		// Entity ID
		canonicalID := canonicalizeVulnerabilityID(&v)
		entityIDMap := attrs.PutEmptyMap(constants.AttributeOtelEntityID)
		entityIDMap.PutStr(constants.AttributeVulnerabilityID, canonicalID)

		// Entity Attributes
		entityAttrs := attrs.PutEmptyMap(constants.AttributeOtelEntityAttributes)
		entityAttrs.PutStr(constants.AttributeVulnerabilityID, canonicalID)
		entityAttrs.PutStr(constants.AttributeVulnerabilityDescription, v.Title)
		entityAttrs.PutStr(constants.AttributeVulnerabilitySeverity, v.Severity)

		if v.Score > 0 {
			entityAttrs.PutDouble(constants.AttributeVulnerabilityScoreBase, v.Score)
		}

		// Enumeration
		if strings.HasPrefix(canonicalID, "CVE") {
			entityAttrs.PutStr(constants.AttributeVulnerabilityEnumeration, "CVE")
		} else if strings.HasPrefix(canonicalID, "GHSA") {
			entityAttrs.PutStr(constants.AttributeVulnerabilityEnumeration, "GHSA")
		} else if strings.HasPrefix(canonicalID, "OSV") {
			entityAttrs.PutStr(constants.AttributeVulnerabilityEnumeration, "OSV")
		}

		// Build vulnerability.reference array
		references := entityAttrs.PutEmptySlice(constants.AttributeVulnerabilityReference)
		if v.PrimaryLink != "" {
			references.AppendEmpty().SetStr(v.PrimaryLink)
		}
		for _, link := range v.Links {
			if link != "" && link != v.PrimaryLink {
				references.AppendEmpty().SetStr(link)
			}
		}
		// Map other fields if available in struct
	}

	return logs
}

func transformVulnerabilitiesToFindingLogs(manifest *manifests.VulnerabilityReportManifest, timestamp pcommon.Timestamp, clusterUID string) plog.LogRecordSlice {
	logs := plog.NewLogRecordSlice()

	for _, v := range manifest.Report.Vulnerabilities {
		canonicalID := canonicalizeVulnerabilityID(&v)

		// Relationship to Image
		if digest := manifest.Report.Artifact.Digest; digest != "" {
			lr := logs.AppendEmpty()
			lr.SetTimestamp(timestamp)
			lr.SetObservedTimestamp(timestamp)

			attrs := lr.Attributes()
			attrs.PutStr(constants.AttributeOtelEntityEventType, constants.EventTypeEntityRelationshipState)
			attrs.PutStr(constants.AttributeOtelEntityRelationshipType, constants.RelationshipTypeVulnerabilityFinding)
			attrs.PutStr(srcEntityType, constants.EntityTypeVulnerability)
			attrs.PutStr(destEntityType, k8sContainerImageEntityType)

			// Source Entity ID (Vulnerability)
			sourceIDMap := attrs.PutEmptyMap(constants.AttributeOtelEntityRelationshipSourceEntityID)
			sourceIDMap.PutStr(constants.AttributeVulnerabilityID, canonicalID)

			// Destination Entity ID (Image)
			destIDMap := attrs.PutEmptyMap(constants.AttributeOtelEntityRelationshipDestinationEntityID)
			destIDMap.PutStr(constants.AttributeOciManifestDigest, extractSha256Digest(digest))
			normalizedName := normalizeVulnerabilityReportImage(manifest.Report.Registry.Server, manifest.Report.Artifact.Repository, manifest.Report.Artifact.Tag)
			destIDMap.PutStr(string(conventions.ContainerImageNameKey), normalizedName)

			// Attributes
			relAttrs := attrs.PutEmptyMap(constants.AttributeOtelEntityRelationshipAttributes)

			populateCommonRelationshipAttributes(relAttrs, manifest)
		}
	}

	return logs
}

func populateCommonRelationshipAttributes(attrs pcommon.Map, manifest *manifests.VulnerabilityReportManifest) {
	attrs.PutStr(constants.AttributeScannerVendor, manifest.Report.Scanner.Vendor)
	attrs.PutStr(constants.AttributeScannerName, manifest.Report.Scanner.Name)
	attrs.PutStr(constants.AttributeScannerVersion, manifest.Report.Scanner.Version)
}

func transformVulnerabilityReportToContainerImageLog(manifest *manifests.VulnerabilityReportManifest, t pcommon.Timestamp) plog.LogRecordSlice {
	lrs := plog.NewLogRecordSlice()

	if manifest.Report.Artifact.Digest == "" {
		return lrs
	}

	lr := lrs.AppendEmpty()
	lr.SetObservedTimestamp(t)

	attrs := lr.Attributes()
	attrs.PutStr(otelEntityEventType, entityState)
	attrs.PutStr(swEntityType, k8sContainerImageEntityType)

	tm := attrs.PutEmptyMap(otelEntityId)
	tm.PutStr(constants.AttributeOciManifestDigest, extractSha256Digest(manifest.Report.Artifact.Digest))
	normalizedName := normalizeVulnerabilityReportImage(manifest.Report.Registry.Server, manifest.Report.Artifact.Repository, manifest.Report.Artifact.Tag)
	tm.PutStr(string(conventions.ContainerImageNameKey), normalizedName)

	entityAttrs := attrs.PutEmptyMap(constants.AttributeOtelEntityAttributes)
	tags := entityAttrs.PutEmptySlice(constants.AttributeContainerImageTags)
	if manifest.Report.Artifact.Tag != "" {
		tags.AppendEmpty().SetStr(manifest.Report.Artifact.Tag)
	}

	return lrs
}
