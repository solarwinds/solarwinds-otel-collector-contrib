// Copyright 2025 SolarWinds Worldwide, LLC. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package k8seventgenerationprocessor

import (
	"strings"

	"github.com/google/go-containerregistry/pkg/name"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/plog"
	conventions "go.opentelemetry.io/otel/semconv/v1.21.0"

	"github.com/solarwinds/solarwinds-otel-collector-contrib/processor/k8seventgenerationprocessor/internal/constants"
	"github.com/solarwinds/solarwinds-otel-collector-contrib/processor/k8seventgenerationprocessor/internal/manifests"
)

func extractSha256Digest(fullDigest string) string {
	if fullDigest == "" {
		return ""
	}

	// Strip container runtime prefixes
	runtimePrefixes := []string{
		"docker://",
		"containerd://",
		"cri-o://",
		"docker-pullable://",
	}

	digest := fullDigest
	for _, prefix := range runtimePrefixes {
		digest = strings.TrimPrefix(digest, prefix)
	}

	// Extract digest after @ symbol (e.g., "nginx@sha256:abc")
	if idx := strings.Index(digest, "@"); idx != -1 {
		digest = digest[idx+1:]
	}

	// Check if digest contains an algorithm prefix (sha256:, sha512:, etc.)
	if idx := strings.Index(digest, ":"); idx != -1 {
		algorithm := digest[:idx]
		hash := digest[idx+1:]
		// Normalize algorithm to lowercase
		return strings.ToLower(algorithm) + ":" + hash
	}

	// No algorithm prefix found, assume sha256
	return "sha256:" + digest
}

func normalizeVulnerabilityReportImage(registry, repository, tag string) string {
	if repository == "" {
		return ""
	}

	// Reconstruct full image reference from Trivy's split format
	imageRef := repository

	// Prepend registry server if present
	if registry != "" {
		imageRef = registry + "/" + repository
	}

	// Append tag if present
	if tag != "" {
		imageRef += ":" + tag
	}

	// Parse using go-containerregistry to normalize and get full registry+repository
	ref, err := name.ParseReference(imageRef)
	if err != nil {
		// Fall back to constructed imageRef (preserves registry)
		return imageRef
	}

	// Use Name() to get full registry+repository path (not RepositoryStr())
	// This matches OTel semantics and ensures proper entity matching
	return ref.Context().Name()
}

func canonicalizeVulnerabilityID(v *manifests.Vulnerability) string {
	// Currently we only have VulnerabilityID from the manifest.
	// If future requirements allow choosing from multiple IDs (CVE, OSV, GHSA),
	// the precedence logic should be implemented here.
	return v.VulnerabilityID
}

// extractCVSSScore extracts the CVSS score and version from the vulnerability's CVSS field.
// Returns (score, version) where version is "3.0" or "2.0", or (0, "") if no CVSS data is available.
// Precedence: nvd.V3Score > redhat.V3Score > nvd.V2Score > redhat.V2Score
func extractCVSSScore(v *manifests.Vulnerability) (float64, string) {
	// Prefer NVD V3 score
	if v.CVSS.NVD.V3Score > 0 {
		return v.CVSS.NVD.V3Score, "3.0"
	}

	// Fallback to RedHat V3 score
	if v.CVSS.RedHat.V3Score > 0 {
		return v.CVSS.RedHat.V3Score, "3.0"
	}

	// Fallback to NVD V2 score
	if v.CVSS.NVD.V2Score > 0 {
		return v.CVSS.NVD.V2Score, "2.0"
	}

	// Fallback to RedHat V2 score
	if v.CVSS.RedHat.V2Score > 0 {
		return v.CVSS.RedHat.V2Score, "2.0"
	}

	// No CVSS data available
	return 0, ""
}

// calculateSeverityFromScore derives a severity tier (CRITICAL, HIGH, MEDIUM, LOW)
// from a CVSS base score using industry-standard ranges.
// Returns empty string if score is invalid or missing.
func calculateSeverityFromScore(score float64) string {
	// Handle invalid inputs
	if score <= 0 {
		return ""
	}
	if score > 10.0 {
		score = 10.0
	}

	// Calculate severity based on CVSS score ranges
	if score >= 9.0 {
		return "CRITICAL"
	}
	if score >= 7.0 {
		return "HIGH"
	}
	if score >= 4.0 {
		return "MEDIUM"
	}
	return "LOW"
}

func transformVulnerabilitiesToEntityLogs(manifest *manifests.VulnerabilityReportManifest, timestamp pcommon.Timestamp, clusterUID string) plog.LogRecordSlice {
	logs := plog.NewLogRecordSlice()

	for _, v := range manifest.Report.Vulnerabilities {
		// Skip vulnerabilities without resource information
		if v.Resource == "" {
			continue
		}

		lr := logs.AppendEmpty()
		lr.SetTimestamp(timestamp)
		lr.SetObservedTimestamp(timestamp)

		attrs := lr.Attributes()
		attrs.PutStr(constants.AttributeOtelEntityEventType, constants.EventTypeEntityState)
		attrs.PutStr(constants.AttributeOtelEntityType, constants.EntityTypeVulnerability)

		// Entity ID: Composite key with vulnerability.id, resource, and installed_version
		canonicalID := canonicalizeVulnerabilityID(&v)
		entityIDMap := attrs.PutEmptyMap(constants.AttributeOtelEntityID)
		entityIDMap.PutStr(constants.AttributeVulnerabilityID, canonicalID)
		entityIDMap.PutStr(constants.AttributeFindingResource, v.Resource)
		entityIDMap.PutStr(constants.AttributeFindingInstalledVersion, v.InstalledVersion)

		// Entity Attributes
		entityAttrs := attrs.PutEmptyMap(constants.AttributeOtelEntityAttributes)
		entityAttrs.PutStr(constants.AttributeVulnerabilityID, canonicalID)

		// Use description field with fallback to title
		description := v.Description
		if description == "" {
			description = v.Title
		}
		entityAttrs.PutStr(constants.AttributeVulnerabilityDescription, description)

		// Extract CVSS score and version
		cvssScore, cvssVersion := extractCVSSScore(&v)
		if cvssScore > 0 {
			entityAttrs.PutDouble(constants.AttributeVulnerabilityScoreBase, cvssScore)
			entityAttrs.PutStr(constants.AttributeVulnerabilityScoreVersion, cvssVersion)
			// Set calculated severity on entity (base severity from CVSS score)
			calculatedSeverity := calculateSeverityFromScore(cvssScore)
			if calculatedSeverity != "" {
				entityAttrs.PutStr(constants.AttributeVulnerabilitySeverity, calculatedSeverity)
			}
		} else if v.Score > 0 {
			// Fallback to legacy score field if CVSS is not available
			entityAttrs.PutDouble(constants.AttributeVulnerabilityScoreBase, v.Score)
			calculatedSeverity := calculateSeverityFromScore(v.Score)
			if calculatedSeverity != "" {
				entityAttrs.PutStr(constants.AttributeVulnerabilitySeverity, calculatedSeverity)
			}
		}

		entityAttrs.PutStr(constants.AttributeVulnerabilityClassification, "CVSS")

		if v.PublishedDate != "" {
			entityAttrs.PutStr(constants.AttributeVulnerabilityPublishedDate, v.PublishedDate)
		}
		if v.LastModifiedDate != "" {
			entityAttrs.PutStr(constants.AttributeVulnerabilityLastModifiedDate, v.LastModifiedDate)
		}

		// Enumeration
		if strings.HasPrefix(canonicalID, "CVE") {
			entityAttrs.PutStr(constants.AttributeVulnerabilityEnumeration, "CVE")
		} else if strings.HasPrefix(canonicalID, "GHSA") {
			entityAttrs.PutStr(constants.AttributeVulnerabilityEnumeration, "GHSA")
		} else if strings.HasPrefix(canonicalID, "OSV") {
			entityAttrs.PutStr(constants.AttributeVulnerabilityEnumeration, "OSV")
		}

		// Build vulnerability.reference array
		references := entityAttrs.PutEmptySlice(constants.AttributeVulnerabilityReference)
		if v.PrimaryLink != "" {
			references.AppendEmpty().SetStr(v.PrimaryLink)
		}
		for _, link := range v.Links {
			if link != "" && link != v.PrimaryLink {
				references.AppendEmpty().SetStr(link)
			}
		}

		// Add finding properties
		entityAttrs.PutStr(constants.AttributeFindingResource, v.Resource)
		entityAttrs.PutStr(constants.AttributeFindingInstalledVersion, v.InstalledVersion)
		entityAttrs.PutStr(constants.AttributeFindingFixedVersion, v.FixedVersion)

		// Add vendor severity if available (scanner's environmental/contextual assessment)
		// This is Trivy's severity rating which may differ from calculated severity
		// due to environmental factors, exploit availability, or vendor-specific heuristics
		if v.Severity != "" {
			entityAttrs.PutStr(constants.AttributeFindingVendorSeverity, v.Severity)
		}

		// Set environmental score from the Score field
		// This may be an environmental score or scanner-calculated contextual score
		if v.Score > 0 {
			entityAttrs.PutDouble(constants.AttributeFindingScoreEnvironmental, v.Score)
		}
	}

	return logs
}

func transformVulnerabilitiesToFindingLogs(manifest *manifests.VulnerabilityReportManifest, timestamp pcommon.Timestamp, clusterUID string) plog.LogRecordSlice {
	logs := plog.NewLogRecordSlice()

	if manifest.Report.Artifact.Digest == "" {
		return logs
	}

	for _, v := range manifest.Report.Vulnerabilities {
		if v.Resource == "" {
			continue
		}

		canonicalID := canonicalizeVulnerabilityID(&v)
		digest := extractSha256Digest(manifest.Report.Artifact.Digest)
		normalizedName := normalizeVulnerabilityReportImage(manifest.Report.Registry.Server, manifest.Report.Artifact.Repository, manifest.Report.Artifact.Tag)

		lr := logs.AppendEmpty()
		lr.SetTimestamp(timestamp)
		lr.SetObservedTimestamp(timestamp)

		attrs := lr.Attributes()
		attrs.PutStr(constants.AttributeOtelEntityEventType, constants.EventTypeEntityRelationshipState)
		attrs.PutStr(constants.AttributeOtelEntityRelationshipType, constants.RelationshipTypeVulnerabilityFinding)
		attrs.PutStr(srcEntityType, constants.EntityTypeVulnerability)
		attrs.PutStr(destEntityType, k8sContainerImageEntityType)

		// Source: VulnerabilityDetail with 3-key composite ID
		sourceIDMap := attrs.PutEmptyMap(constants.AttributeOtelEntityRelationshipSourceEntityID)
		sourceIDMap.PutStr(constants.AttributeVulnerabilityID, canonicalID)
		sourceIDMap.PutStr(constants.AttributeFindingResource, v.Resource)
		sourceIDMap.PutStr(constants.AttributeFindingInstalledVersion, v.InstalledVersion)

		// Destination: KubernetesContainerImage
		destIDMap := attrs.PutEmptyMap(constants.AttributeOtelEntityRelationshipDestinationEntityID)
		destIDMap.PutStr(constants.AttributeOciManifestDigest, digest)
		destIDMap.PutStr(string(conventions.ContainerImageNameKey), normalizedName)

		// Relationship attributes: Scanner metadata
		relAttrs := attrs.PutEmptyMap(constants.AttributeOtelEntityRelationshipAttributes)
		relAttrs.PutStr(constants.AttributeScannerVendor, manifest.Report.Scanner.Vendor)
		relAttrs.PutStr(constants.AttributeScannerName, manifest.Report.Scanner.Name)
		relAttrs.PutStr(constants.AttributeScannerVersion, manifest.Report.Scanner.Version)
	}

	return logs
}

func transformVulnerabilityReportToContainerImageLog(manifest *manifests.VulnerabilityReportManifest, t pcommon.Timestamp) plog.LogRecordSlice {
	lrs := plog.NewLogRecordSlice()

	if manifest.Report.Artifact.Digest == "" {
		return lrs
	}

	lr := lrs.AppendEmpty()
	lr.SetObservedTimestamp(t)

	attrs := lr.Attributes()
	attrs.PutStr(otelEntityEventType, entityState)
	attrs.PutStr(swEntityType, k8sContainerImageEntityType)

	tm := attrs.PutEmptyMap(otelEntityId)
	tm.PutStr(constants.AttributeOciManifestDigest, extractSha256Digest(manifest.Report.Artifact.Digest))
	normalizedName := normalizeVulnerabilityReportImage(manifest.Report.Registry.Server, manifest.Report.Artifact.Repository, manifest.Report.Artifact.Tag)
	tm.PutStr(string(conventions.ContainerImageNameKey), normalizedName)

	entityAttrs := attrs.PutEmptyMap(constants.AttributeOtelEntityAttributes)
	tags := entityAttrs.PutEmptySlice(constants.AttributeContainerImageTags)
	if manifest.Report.Artifact.Tag != "" {
		tags.AppendEmpty().SetStr(manifest.Report.Artifact.Tag)
	}

	return lrs
}
