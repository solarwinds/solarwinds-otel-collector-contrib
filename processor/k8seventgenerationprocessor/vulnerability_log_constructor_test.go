// Copyright 2025 SolarWinds Worldwide, LLC. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package k8seventgenerationprocessor

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.opentelemetry.io/collector/pdata/pcommon"

	"github.com/solarwinds/solarwinds-otel-collector-contrib/processor/k8seventgenerationprocessor/internal/constants"
	"github.com/solarwinds/solarwinds-otel-collector-contrib/processor/k8seventgenerationprocessor/internal/manifests"
)

func TestExtractCVSSScore(t *testing.T) {
	tests := []struct {
		name          string
		vulnerability manifests.Vulnerability
		expectedScore float64
		expectedVer   string
	}{
		{
			name: "NVD V3 score is preferred",
			vulnerability: manifests.Vulnerability{
				CVSS: manifests.CVSS{
					NVD: manifests.CVSSSource{
						V2Score: 5.0,
						V3Score: 7.5,
					},
					RedHat: manifests.CVSSSource{
						V2Score: 6.0,
						V3Score: 8.0,
					},
				},
			},
			expectedScore: 7.5,
			expectedVer:   "3.0",
		},
		{
			name: "RedHat V3 score used when NVD V3 is missing",
			vulnerability: manifests.Vulnerability{
				CVSS: manifests.CVSS{
					NVD: manifests.CVSSSource{
						V2Score: 5.0,
					},
					RedHat: manifests.CVSSSource{
						V3Score: 8.6,
					},
				},
			},
			expectedScore: 8.6,
			expectedVer:   "3.0",
		},
		{
			name: "NVD V2 score used when V3 scores missing",
			vulnerability: manifests.Vulnerability{
				CVSS: manifests.CVSS{
					NVD: manifests.CVSSSource{
						V2Score: 4.3,
					},
					RedHat: manifests.CVSSSource{
						V2Score: 5.1,
					},
				},
			},
			expectedScore: 4.3,
			expectedVer:   "2.0",
		},
		{
			name: "RedHat V2 score used as last fallback",
			vulnerability: manifests.Vulnerability{
				CVSS: manifests.CVSS{
					RedHat: manifests.CVSSSource{
						V2Score: 6.2,
					},
				},
			},
			expectedScore: 6.2,
			expectedVer:   "2.0",
		},
		{
			name: "No CVSS data returns zero and empty string",
			vulnerability: manifests.Vulnerability{
				CVSS: manifests.CVSS{},
			},
			expectedScore: 0,
			expectedVer:   "",
		},
		{
			name: "Legacy score field ignored when CVSS present",
			vulnerability: manifests.Vulnerability{
				Score: 9.9,
				CVSS: manifests.CVSS{
					NVD: manifests.CVSSSource{
						V3Score: 6.5,
					},
				},
			},
			expectedScore: 6.5,
			expectedVer:   "3.0",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			score, version := extractCVSSScore(&tt.vulnerability)
			assert.Equal(t, tt.expectedScore, score)
			assert.Equal(t, tt.expectedVer, version)
		})
	}
}

func TestCVSSScoreVersionInTransformedLogs(t *testing.T) {
	// Create a minimal manifest with CVSS data
	manifest := &manifests.VulnerabilityReportManifest{
		Report: manifests.VulnerabilityReportReport{
			Artifact: manifests.VulnerabilityReportArtifact{
				Digest:     "sha256:abc123",
				Repository: "test-repo",
				Tag:        "latest",
			},
			Registry: manifests.VulnerabilityReportRegistry{
				Server: "registry.test.io",
			},
			Scanner: manifests.VulnerabilityReportScanner{
				Name:    "Trivy",
				Vendor:  "Aqua Security",
				Version: "0.66.0",
			},
			Vulnerabilities: []manifests.Vulnerability{
				{
					VulnerabilityID: "CVE-2024-TEST",
					Title:           "Test vulnerability",
					Description:     "Detailed description for testing",
					CVSS: manifests.CVSS{
						NVD: manifests.CVSSSource{
							V3Score:  7.5,
							V3Vector: "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
						},
					},
					Resource:         "test-package",
					InstalledVersion: "1.0.0",
					FixedVersion:     "1.0.1",
					Severity:         "HIGH",
					PrimaryLink:      "https://example.com/CVE-2024-TEST",
					Links:            []string{"https://example.com/advisory"},
				},
			},
		},
	}

	timestamp := pcommon.NewTimestampFromTime(time.Now())
	logs := transformVulnerabilitiesToEntityLogs(manifest, timestamp, "test-cluster")

	require.Equal(t, 1, logs.Len())

	lr := logs.At(0)
	attrs := lr.Attributes()
	entityAttrs, exists := attrs.Get(constants.AttributeOtelEntityAttributes)
	require.True(t, exists)

	entityAttrsMap := entityAttrs.Map()

	// Verify score.base
	scoreBase, scoreExists := entityAttrsMap.Get(constants.AttributeVulnerabilityScoreBase)
	assert.True(t, scoreExists, "vulnerability.score.base should be present")
	assert.Equal(t, 7.5, scoreBase.Double())

	// Verify score.version
	scoreVersion, versionExists := entityAttrsMap.Get(constants.AttributeVulnerabilityScoreVersion)
	assert.True(t, versionExists, "vulnerability.score.version should be present")
	assert.Equal(t, "3.0", scoreVersion.Str())

	// Verify description uses the Description field, not Title
	description, descExists := entityAttrsMap.Get(constants.AttributeVulnerabilityDescription)
	assert.True(t, descExists)
	assert.Equal(t, "Detailed description for testing", description.Str())

	// Verify reference array contains primaryLink first
	references, refExists := entityAttrsMap.Get(constants.AttributeVulnerabilityReference)
	assert.True(t, refExists)
	refSlice := references.Slice()
	assert.Equal(t, 2, refSlice.Len())
	assert.Equal(t, "https://example.com/CVE-2024-TEST", refSlice.At(0).Str(), "Primary link should be first")
	assert.Equal(t, "https://example.com/advisory", refSlice.At(1).Str())
}

func TestVulnerabilityResourceFindingEntityAttributes(t *testing.T) {
	// Test that the VulnerabilityDetail entity contains
	// all finding properties in a single entity
	manifest := &manifests.VulnerabilityReportManifest{
		Report: manifests.VulnerabilityReportReport{
			Artifact: manifests.VulnerabilityReportArtifact{
				Digest:     "sha256:abc123def456",
				Repository: "test-repo",
				Tag:        "v1.0",
			},
			Registry: manifests.VulnerabilityReportRegistry{
				Server: "registry.test.io",
			},
			Scanner: manifests.VulnerabilityReportScanner{
				Name:    "Trivy",
				Vendor:  "Aqua Security",
				Version: "0.66.0",
			},
			Vulnerabilities: []manifests.Vulnerability{
				{
					VulnerabilityID: "CVE-2024-FINDING-TEST",
					CVSS: manifests.CVSS{
						NVD: manifests.CVSSSource{
							V3Score:  8.2,
							V3Vector: "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:N",
						},
					},
					Resource:         "libtest",
					InstalledVersion: "2.3.4",
					FixedVersion:     "2.3.5",
					Severity:         "HIGH",
				},
			},
		},
	}

	timestamp := pcommon.NewTimestampFromTime(time.Now())
	logs := transformVulnerabilitiesToEntityLogs(manifest, timestamp, "test-cluster")

	require.Equal(t, 1, logs.Len())

	lr := logs.At(0)
	attrs := lr.Attributes()

	// Verify entity type is VulnerabilityDetail
	entityType, typeExists := attrs.Get(constants.AttributeOtelEntityType)
	assert.True(t, typeExists)
	assert.Equal(t, constants.EntityTypeVulnerability, entityType.Str())

	// Verify entity ID contains the 3 required keys (composite ID)
	entityID, idExists := attrs.Get(constants.AttributeOtelEntityID)
	require.True(t, idExists)
	entityIDMap := entityID.Map()
	assert.Equal(t, 3, entityIDMap.Len(), "Entity ID should have exactly 3 keys")

	vulnID, vulnIDExists := entityIDMap.Get(constants.AttributeVulnerabilityID)
	assert.True(t, vulnIDExists)
	assert.Equal(t, "CVE-2024-FINDING-TEST", vulnID.Str())

	resource, resourceExists := entityIDMap.Get(constants.AttributeFindingResource)
	assert.True(t, resourceExists)
	assert.Equal(t, "libtest", resource.Str())

	installedVer, installedExists := entityIDMap.Get(constants.AttributeFindingInstalledVersion)
	assert.True(t, installedExists)
	assert.Equal(t, "2.3.4", installedVer.Str())

	// Verify entity attributes contain merged properties
	entityAttrs, attrsExists := attrs.Get(constants.AttributeOtelEntityAttributes)
	require.True(t, attrsExists)
	entityAttrsMap := entityAttrs.Map()

	// Verify base CVSS score
	baseScore, baseScoreExists := entityAttrsMap.Get(constants.AttributeVulnerabilityScoreBase)
	assert.True(t, baseScoreExists, "vulnerability.score.base should be present")
	assert.Equal(t, 8.2, baseScore.Double())

	// Verify environmental score is NOT present (Trivy doesn't provide environmental scores)
	_, envScoreExists := entityAttrsMap.Get(constants.AttributeFindingScoreEnvironmental)
	assert.False(t, envScoreExists, "vulnerability.score.environmental should NOT be present (Trivy doesn't provide it)")

	// Verify score version
	scoreVersion, versionExists := entityAttrsMap.Get(constants.AttributeVulnerabilityScoreVersion)
	assert.True(t, versionExists, "vulnerability.score.version should be present")
	assert.Equal(t, "3.0", scoreVersion.Str())

	// Verify finding properties
	assert.Equal(t, "CVE-2024-FINDING-TEST", getStringFromMap(entityAttrsMap, constants.AttributeVulnerabilityID))
	assert.Equal(t, "libtest", getStringFromMap(entityAttrsMap, constants.AttributeFindingResource))
	assert.Equal(t, "2.3.4", getStringFromMap(entityAttrsMap, constants.AttributeFindingInstalledVersion))
	assert.Equal(t, "2.3.5", getStringFromMap(entityAttrsMap, constants.AttributeFindingFixedVersion))
	assert.Equal(t, "HIGH", getStringFromMap(entityAttrsMap, constants.AttributeFindingVendorSeverity))

	// Note: Scanner metadata is now in the relationship, not in the entity
}

func getStringFromMap(m pcommon.Map, key string) string {
	val, exists := m.Get(key)
	if !exists {
		return ""
	}
	return val.Str()
}

func TestNormalizeVulnerabilityReportImage(t *testing.T) {
	tests := []struct {
		name       string
		registry   string
		repository string
		tag        string
		expected   string
	}{
		{
			name:       "Docker Hub official image without registry",
			registry:   "",
			repository: "kube-proxy",
			tag:        "v1.32.2",
			expected:   "index.docker.io/library/kube-proxy",
		},
		{
			name:       "Docker Hub official image without tag",
			registry:   "",
			repository: "nginx",
			tag:        "",
			expected:   "index.docker.io/library/nginx",
		},
		{
			name:       "Custom registry with full path",
			registry:   "",
			repository: "gcr.io/project/image",
			tag:        "v1.0",
			expected:   "gcr.io/project/image",
		},
		{
			name:       "Docker Hub user image",
			registry:   "",
			repository: "myuser/myimage",
			tag:        "latest",
			expected:   "index.docker.io/myuser/myimage",
		},
		{
			name:       "Empty repository",
			registry:   "",
			repository: "",
			tag:        "v1.0",
			expected:   "",
		},
		{
			name:       "Registry with port",
			registry:   "",
			repository: "localhost:5000/myimage",
			tag:        "dev",
			expected:   "localhost:5000/myimage",
		},
		{
			name:       "Kubernetes registry from Trivy",
			registry:   "registry.k8s.io",
			repository: "kube-proxy",
			tag:        "v1.32.2",
			expected:   "registry.k8s.io/kube-proxy",
		},
		{
			name:       "GCR registry from Trivy",
			registry:   "gcr.io",
			repository: "project/image",
			tag:        "latest",
			expected:   "gcr.io/project/image",
		},
		{
			name:       "Docker Hub with explicit registry",
			registry:   "docker.io",
			repository: "library/nginx",
			tag:        "alpine",
			expected:   "index.docker.io/library/nginx",
		},
		{
			name:       "Private registry without tag",
			registry:   "my-registry.company.com",
			repository: "team/app",
			tag:        "",
			expected:   "my-registry.company.com/team/app",
		},
		{
			name:       "Registry with port and path",
			registry:   "localhost:5000",
			repository: "myapp",
			tag:        "v2.0",
			expected:   "localhost:5000/myapp",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := normalizeVulnerabilityReportImage(tt.registry, tt.repository, tt.tag)
			assert.Equal(t, tt.expected, result)
		})
	}
}
